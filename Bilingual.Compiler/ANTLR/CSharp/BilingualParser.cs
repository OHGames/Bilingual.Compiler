//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.12.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from BilingualParser.g4 by ANTLR 4.12.0

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.12.0")]
[System.CLSCompliant(false)]
public partial class BilingualParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		CurlyOpen=1, CurlyClosed=2, SquareOpen=3, SquareClosed=4, ParenOpen=5, 
		ParenClosed=6, Semicolon=7, Colon=8, Equal=9, NotEqual=10, Bang=11, EqualTo=12, 
		PlusEqual=13, MinusEqual=14, MulEqual=15, DivEqual=16, Mod=17, Pow=18, 
		Mul=19, Div=20, Add=21, Sub=22, GreaterThan=23, LessThan=24, GreaterThanEqual=25, 
		LessThanEqual=26, Dot=27, Comma=28, Hash=29, True=30, False=31, If=32, 
		ElseIf=33, Else=34, While=35, Do=36, For=37, Foreach=38, Continue=39, 
		Break=40, Return=41, Await=42, Var=43, Global=44, In=45, Choose=46, Run=47, 
		Inject=48, Zero=49, One=50, Two=51, Other=52, Few=53, Many=54, Plural=55, 
		Ordinal=56, MemberName=57, Number=58, LineId=59, LineIdComment=60, DoubleQuote=61, 
		DollarDouble=62, WS=63, Comment=64, String=65, Grapheme=66, EscapedLeftBrace=67, 
		EscapedQuote=68, EscapedBackslash=69;
	public const int
		RULE_file = 0, RULE_container = 1, RULE_script = 2, RULE_scriptAttributes = 3, 
		RULE_expression = 4, RULE_literal = 5, RULE_block = 6, RULE_statement = 7, 
		RULE_variableDeclaration = 8, RULE_memberAssignment = 9, RULE_member = 10, 
		RULE_ifStatement = 11, RULE_ifElseStatement = 12, RULE_elseStatement = 13, 
		RULE_whileStatement = 14, RULE_doWhileStatement = 15, RULE_forStatement = 16, 
		RULE_forEachStatement = 17, RULE_dialogueStatement = 18, RULE_dialogueEmotion = 19, 
		RULE_chooseStatement = 20, RULE_chooseBlock = 21, RULE_functionCall = 22, 
		RULE_param = 23, RULE_arrayIndexer = 24, RULE_arrayObject = 25, RULE_arrayAccess = 26, 
		RULE_runStatement = 27, RULE_injectStatement = 28, RULE_unaryIncrementLeft = 29, 
		RULE_unaryIncrementRight = 30, RULE_unaryDecrementLeft = 31, RULE_unaryDecrementRight = 32, 
		RULE_plusMinusMulDivEqual = 33, RULE_incrementsAndDecrements = 34, RULE_stringContents = 35, 
		RULE_lotsOfGraphemes = 36, RULE_interpolationString = 37, RULE_pluralizedQuantity = 38, 
		RULE_pluralCountParam = 39;
	public static readonly string[] ruleNames = {
		"file", "container", "script", "scriptAttributes", "expression", "literal", 
		"block", "statement", "variableDeclaration", "memberAssignment", "member", 
		"ifStatement", "ifElseStatement", "elseStatement", "whileStatement", "doWhileStatement", 
		"forStatement", "forEachStatement", "dialogueStatement", "dialogueEmotion", 
		"chooseStatement", "chooseBlock", "functionCall", "param", "arrayIndexer", 
		"arrayObject", "arrayAccess", "runStatement", "injectStatement", "unaryIncrementLeft", 
		"unaryIncrementRight", "unaryDecrementLeft", "unaryDecrementRight", "plusMinusMulDivEqual", 
		"incrementsAndDecrements", "stringContents", "lotsOfGraphemes", "interpolationString", 
		"pluralizedQuantity", "pluralCountParam"
	};

	private static readonly string[] _LiteralNames = {
		null, "'{'", "'}'", "'['", "']'", "'('", "')'", "';'", "':'", "'='", "'!='", 
		"'!'", "'=='", "'+='", "'-='", "'*='", "'/='", "'%'", "'^'", "'*'", "'/'", 
		"'+'", "'-'", "'>'", "'<'", "'<='", "'>='", "'.'", "','", "'#'", "'true'", 
		"'false'", "'if'", "'else if'", "'else'", "'while'", "'do'", "'for'", 
		"'foreach'", "'continue'", "'break'", "'return'", "'await'", "'var'", 
		"'global'", "'in'", "'choose'", "'run'", "'inject'", "'zero'", "'one'", 
		"'two'", "'other'", "'few'", "'many'", null, null, null, null, null, null, 
		null, "'$\"'", null, null, null, null, "'\\{'", "'\\\"'", "'\\\\'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "CurlyOpen", "CurlyClosed", "SquareOpen", "SquareClosed", "ParenOpen", 
		"ParenClosed", "Semicolon", "Colon", "Equal", "NotEqual", "Bang", "EqualTo", 
		"PlusEqual", "MinusEqual", "MulEqual", "DivEqual", "Mod", "Pow", "Mul", 
		"Div", "Add", "Sub", "GreaterThan", "LessThan", "GreaterThanEqual", "LessThanEqual", 
		"Dot", "Comma", "Hash", "True", "False", "If", "ElseIf", "Else", "While", 
		"Do", "For", "Foreach", "Continue", "Break", "Return", "Await", "Var", 
		"Global", "In", "Choose", "Run", "Inject", "Zero", "One", "Two", "Other", 
		"Few", "Many", "Plural", "Ordinal", "MemberName", "Number", "LineId", 
		"LineIdComment", "DoubleQuote", "DollarDouble", "WS", "Comment", "String", 
		"Grapheme", "EscapedLeftBrace", "EscapedQuote", "EscapedBackslash"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "BilingualParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static BilingualParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public BilingualParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public BilingualParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class FileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ContainerContext[] container() {
			return GetRuleContexts<ContainerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ContainerContext container(int i) {
			return GetRuleContext<ContainerContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(BilingualParser.Eof, 0); }
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(Context, State);
		EnterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 80;
				container();
				}
				}
				State = 83;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==MemberName );
			State = 86;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				{
				State = 85;
				Match(Eof);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContainerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyOpen() { return GetToken(BilingualParser.CurlyOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyClosed() { return GetToken(BilingualParser.CurlyClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ScriptContext[] script() {
			return GetRuleContexts<ScriptContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScriptContext script(int i) {
			return GetRuleContext<ScriptContext>(i);
		}
		public ContainerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_container; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContainer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContainerContext container() {
		ContainerContext _localctx = new ContainerContext(Context, State);
		EnterRule(_localctx, 2, RULE_container);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88;
			member();
			State = 89;
			Match(CurlyOpen);
			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==SquareOpen || _la==MemberName) {
				{
				{
				State = 90;
				script();
				}
				}
				State = 95;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 96;
			Match(CurlyClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName() { return GetToken(BilingualParser.MemberName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScriptAttributesContext[] scriptAttributes() {
			return GetRuleContexts<ScriptAttributesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScriptAttributesContext scriptAttributes(int i) {
			return GetRuleContext<ScriptAttributesContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 4, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 101;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==SquareOpen) {
				{
				{
				State = 98;
				scriptAttributes();
				}
				}
				State = 103;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 104;
			Match(MemberName);
			State = 105;
			Match(ParenOpen);
			State = 106;
			Match(ParenClosed);
			State = 107;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScriptAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareOpen() { return GetToken(BilingualParser.SquareOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName() { return GetToken(BilingualParser.MemberName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareClosed() { return GetToken(BilingualParser.SquareClosed, 0); }
		public ScriptAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scriptAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScriptAttributes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptAttributesContext scriptAttributes() {
		ScriptAttributesContext _localctx = new ScriptAttributesContext(Context, State);
		EnterRule(_localctx, 6, RULE_scriptAttributes);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			Match(SquareOpen);
			State = 110;
			Match(MemberName);
			State = 111;
			Match(ParenOpen);
			State = 112;
			expression(0);
			State = 113;
			Match(ParenClosed);
			State = 114;
			Match(SquareClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AddSubContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Add() { return GetToken(BilingualParser.Add, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sub() { return GetToken(BilingualParser.Sub, 0); }
		public AddSubContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddSub(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowExprContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Pow() { return GetToken(BilingualParser.Pow, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public PowExprContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BangExpressionContext : ExpressionContext {
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bang() { return GetToken(BilingualParser.Bang, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BangExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBangExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AbsoluteValueExpressionContext : ExpressionContext {
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Add() { return GetToken(BilingualParser.Add, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AbsoluteValueExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbsoluteValueExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotEqualToExprContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NotEqual() { return GetToken(BilingualParser.NotEqual, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public NotEqualToExprContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotEqualToExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GreaterLessThanContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GreaterThan() { return GetToken(BilingualParser.GreaterThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThan() { return GetToken(BilingualParser.LessThan, 0); }
		public GreaterLessThanContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGreaterLessThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesesExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		public ParenthesesExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesesExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NegateExpressionContext : ExpressionContext {
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sub() { return GetToken(BilingualParser.Sub, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public NegateExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegateExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public MemberExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MulDivModContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mul() { return GetToken(BilingualParser.Mul, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Div() { return GetToken(BilingualParser.Div, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mod() { return GetToken(BilingualParser.Mod, 0); }
		public MulDivModContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulDivMod(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PlusMinusMulDivEqualExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlusMinusMulDivEqualContext plusMinusMulDivEqual() {
			return GetRuleContext<PlusMinusMulDivEqualContext>(0);
		}
		public PlusMinusMulDivEqualExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlusMinusMulDivEqualExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCallExprContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public FunctionCallExprContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCallExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GreaterThanLessThanEqualContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GreaterThanEqual() { return GetToken(BilingualParser.GreaterThanEqual, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThanEqual() { return GetToken(BilingualParser.LessThanEqual, 0); }
		public GreaterThanLessThanEqualContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGreaterThanLessThanEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IncrementAndDecrementExprContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncrementsAndDecrementsContext incrementsAndDecrements() {
			return GetRuleContext<IncrementsAndDecrementsContext>(0);
		}
		public IncrementAndDecrementExprContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncrementAndDecrementExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExprContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public LiteralExprContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EqualToExprContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqualTo() { return GetToken(BilingualParser.EqualTo, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public EqualToExprContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqualToExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArrayAccessExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayAccessContext arrayAccess() {
			return GetRuleContext<ArrayAccessContext>(0);
		}
		public ArrayAccessExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 8;
		EnterRecursionRule(_localctx, 8, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 133;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				_localctx = new ParenthesesExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 117;
				Match(ParenOpen);
				State = 118;
				expression(0);
				State = 119;
				Match(ParenClosed);
				}
				break;
			case 2:
				{
				_localctx = new BangExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 121;
				Match(Bang);
				State = 122;
				((BangExpressionContext)_localctx).right = expression(11);
				}
				break;
			case 3:
				{
				_localctx = new NegateExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 123;
				Match(Sub);
				State = 124;
				((NegateExpressionContext)_localctx).right = expression(10);
				}
				break;
			case 4:
				{
				_localctx = new AbsoluteValueExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 125;
				Match(Add);
				State = 126;
				((AbsoluteValueExpressionContext)_localctx).right = expression(9);
				}
				break;
			case 5:
				{
				_localctx = new PlusMinusMulDivEqualExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 127;
				plusMinusMulDivEqual();
				}
				break;
			case 6:
				{
				_localctx = new IncrementAndDecrementExprContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 128;
				incrementsAndDecrements();
				}
				break;
			case 7:
				{
				_localctx = new FunctionCallExprContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 129;
				functionCall();
				}
				break;
			case 8:
				{
				_localctx = new MemberExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 130;
				member();
				}
				break;
			case 9:
				{
				_localctx = new ArrayAccessExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 131;
				arrayAccess();
				}
				break;
			case 10:
				{
				_localctx = new LiteralExprContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 132;
				literal();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 158;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 156;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
					case 1:
						{
						_localctx = new PowExprContext(new ExpressionContext(_parentctx, _parentState));
						((PowExprContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 135;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 136;
						Match(Pow);
						State = 137;
						((PowExprContext)_localctx).right = expression(17);
						}
						break;
					case 2:
						{
						_localctx = new MulDivModContext(new ExpressionContext(_parentctx, _parentState));
						((MulDivModContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 138;
						if (!(Precpred(Context, 15))) throw new FailedPredicateException(this, "Precpred(Context, 15)");
						State = 139;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 1703936L) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 140;
						((MulDivModContext)_localctx).right = expression(16);
						}
						break;
					case 3:
						{
						_localctx = new AddSubContext(new ExpressionContext(_parentctx, _parentState));
						((AddSubContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 141;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 142;
						_la = TokenStream.LA(1);
						if ( !(_la==Add || _la==Sub) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 143;
						((AddSubContext)_localctx).right = expression(15);
						}
						break;
					case 4:
						{
						_localctx = new EqualToExprContext(new ExpressionContext(_parentctx, _parentState));
						((EqualToExprContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 144;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 145;
						Match(EqualTo);
						State = 146;
						((EqualToExprContext)_localctx).right = expression(14);
						}
						break;
					case 5:
						{
						_localctx = new NotEqualToExprContext(new ExpressionContext(_parentctx, _parentState));
						((NotEqualToExprContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 147;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 148;
						Match(NotEqual);
						State = 149;
						((NotEqualToExprContext)_localctx).right = expression(13);
						}
						break;
					case 6:
						{
						_localctx = new GreaterLessThanContext(new ExpressionContext(_parentctx, _parentState));
						((GreaterLessThanContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 150;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 151;
						_la = TokenStream.LA(1);
						if ( !(_la==GreaterThan || _la==LessThan) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 152;
						((GreaterLessThanContext)_localctx).right = expression(8);
						}
						break;
					case 7:
						{
						_localctx = new GreaterThanLessThanEqualContext(new ExpressionContext(_parentctx, _parentState));
						((GreaterThanLessThanEqualContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 153;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 154;
						_la = TokenStream.LA(1);
						if ( !(_la==GreaterThanEqual || _la==LessThanEqual) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 155;
						((GreaterThanLessThanEqualContext)_localctx).right = expression(7);
						}
						break;
					}
					} 
				}
				State = 160;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
	 
		public LiteralContext() { }
		public virtual void CopyFrom(LiteralContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StringLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(BilingualParser.String, 0); }
		public StringLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArrayLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayObjectContext arrayObject() {
			return GetRuleContext<ArrayObjectContext>(0);
		}
		public ArrayLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TrueFalseLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode True() { return GetToken(BilingualParser.True, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode False() { return GetToken(BilingualParser.False, 0); }
		public TrueFalseLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrueFalseLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Number() { return GetToken(BilingualParser.Number, 0); }
		public NumberLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 10, RULE_literal);
		int _la;
		try {
			State = 165;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SquareOpen:
				_localctx = new ArrayLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 161;
				arrayObject();
				}
				break;
			case True:
			case False:
				_localctx = new TrueFalseLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 162;
				_la = TokenStream.LA(1);
				if ( !(_la==True || _la==False) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case Number:
				_localctx = new NumberLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 163;
				Match(Number);
				}
				break;
			case String:
				_localctx = new StringLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 164;
				Match(String);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyOpen() { return GetToken(BilingualParser.CurlyOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyClosed() { return GetToken(BilingualParser.CurlyClosed, 0); }
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 12, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Add:
			case Sub:
			case If:
			case While:
			case Do:
			case For:
			case Foreach:
			case Continue:
			case Break:
			case Return:
			case Await:
			case Var:
			case Global:
			case Choose:
			case Run:
			case Inject:
			case MemberName:
				{
				State = 167;
				statement();
				}
				break;
			case CurlyOpen:
				{
				State = 168;
				Match(CurlyOpen);
				State = 172;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 144642923598708736L) != 0)) {
					{
					{
					State = 169;
					statement();
					}
					}
					State = 174;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 175;
				Match(CurlyClosed);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FunctionCallStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public FunctionCallStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCallStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IncrementDecrementStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncrementsAndDecrementsContext incrementsAndDecrements() {
			return GetRuleContext<IncrementsAndDecrementsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public IncrementDecrementStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncrementDecrementStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RunStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public RunStatementContext runStatement() {
			return GetRuleContext<RunStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public RunStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRunStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ForEachStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ForEachStatementContext forEachStatement() {
			return GetRuleContext<ForEachStatementContext>(0);
		}
		public ForEachStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForEachStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DoWhileStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public DoWhileStatementContext doWhileStatement() {
			return GetRuleContext<DoWhileStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public DoWhileStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoWhileStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ContinueStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(BilingualParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public ContinueStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinueStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ChooseStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ChooseStatementContext chooseStatement() {
			return GetRuleContext<ChooseStatementContext>(0);
		}
		public ChooseStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChooseStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DialogueStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public DialogueStatementContext dialogueStatement() {
			return GetRuleContext<DialogueStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LineId() { return GetToken(BilingualParser.LineId, 0); }
		public DialogueStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDialogueStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PlusMinusMulDivStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlusMinusMulDivEqualContext plusMinusMulDivEqual() {
			return GetRuleContext<PlusMinusMulDivEqualContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public PlusMinusMulDivStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlusMinusMulDivStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableDeclarationStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		public VariableDeclarationStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclarationStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IfStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public IfStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAssignmentStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberAssignmentContext memberAssignment() {
			return GetRuleContext<MemberAssignmentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public MemberAssignmentStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAssignmentStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WhileStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		public WhileStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BreakStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(BilingualParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public BreakStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBreakStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InjectStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public InjectStatementContext injectStatement() {
			return GetRuleContext<InjectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public InjectStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInjectStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ReturnStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(BilingualParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		public ReturnStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ForStmtContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ForStatementContext forStatement() {
			return GetRuleContext<ForStatementContext>(0);
		}
		public ForStmtContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_statement);
		int _la;
		try {
			State = 216;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				_localctx = new DoWhileStmtContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 178;
				doWhileStatement();
				State = 179;
				Match(Semicolon);
				}
				break;
			case 2:
				_localctx = new DialogueStmtContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 181;
				dialogueStatement();
				State = 182;
				Match(Semicolon);
				State = 184;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LineId) {
					{
					State = 183;
					Match(LineId);
					}
				}

				}
				break;
			case 3:
				_localctx = new MemberAssignmentStmtContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 186;
				memberAssignment();
				State = 187;
				Match(Semicolon);
				}
				break;
			case 4:
				_localctx = new FunctionCallStmtContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 189;
				functionCall();
				State = 190;
				Match(Semicolon);
				}
				break;
			case 5:
				_localctx = new IncrementDecrementStmtContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 192;
				incrementsAndDecrements();
				State = 193;
				Match(Semicolon);
				}
				break;
			case 6:
				_localctx = new PlusMinusMulDivStmtContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 195;
				plusMinusMulDivEqual();
				State = 196;
				Match(Semicolon);
				}
				break;
			case 7:
				_localctx = new RunStmtContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 198;
				runStatement();
				State = 199;
				Match(Semicolon);
				}
				break;
			case 8:
				_localctx = new InjectStmtContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 201;
				injectStatement();
				State = 202;
				Match(Semicolon);
				}
				break;
			case 9:
				_localctx = new ContinueStmtContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 204;
				Match(Continue);
				State = 205;
				Match(Semicolon);
				}
				break;
			case 10:
				_localctx = new BreakStmtContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 206;
				Match(Break);
				State = 207;
				Match(Semicolon);
				}
				break;
			case 11:
				_localctx = new ReturnStmtContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 208;
				Match(Return);
				State = 209;
				Match(Semicolon);
				}
				break;
			case 12:
				_localctx = new IfStmtContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 210;
				ifStatement();
				}
				break;
			case 13:
				_localctx = new VariableDeclarationStmtContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 211;
				variableDeclaration();
				}
				break;
			case 14:
				_localctx = new WhileStmtContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 212;
				whileStatement();
				}
				break;
			case 15:
				_localctx = new ForStmtContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 213;
				forStatement();
				}
				break;
			case 16:
				_localctx = new ForEachStmtContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 214;
				forEachStatement();
				}
				break;
			case 17:
				_localctx = new ChooseStmtContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 215;
				chooseStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Var() { return GetToken(BilingualParser.Var, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName() { return GetToken(BilingualParser.MemberName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(BilingualParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(BilingualParser.Global, 0); }
		public VariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclarationContext variableDeclaration() {
		VariableDeclarationContext _localctx = new VariableDeclarationContext(Context, State);
		EnterRule(_localctx, 16, RULE_variableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 219;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global) {
				{
				State = 218;
				Match(Global);
				}
			}

			State = 221;
			Match(Var);
			State = 222;
			Match(MemberName);
			State = 223;
			Match(Equal);
			State = 224;
			expression(0);
			State = 225;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberAssignmentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(BilingualParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MemberAssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberAssignment; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberAssignmentContext memberAssignment() {
		MemberAssignmentContext _localctx = new MemberAssignmentContext(Context, State);
		EnterRule(_localctx, 18, RULE_memberAssignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 227;
			member();
			State = 228;
			Match(Equal);
			State = 229;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MemberName() { return GetTokens(BilingualParser.MemberName); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName(int i) {
			return GetToken(BilingualParser.MemberName, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(BilingualParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(BilingualParser.Dot, i);
		}
		public MemberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_member; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMember(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberContext member() {
		MemberContext _localctx = new MemberContext(Context, State);
		EnterRule(_localctx, 20, RULE_member);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 235;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 231;
					Match(MemberName);
					State = 232;
					Match(Dot);
					}
					} 
				}
				State = 237;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 238;
			Match(MemberName);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(BilingualParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfElseStatementContext[] ifElseStatement() {
			return GetRuleContexts<IfElseStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfElseStatementContext ifElseStatement(int i) {
			return GetRuleContext<IfElseStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseStatementContext elseStatement() {
			return GetRuleContext<ElseStatementContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_ifStatement);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(If);
			State = 241;
			Match(ParenOpen);
			State = 242;
			expression(0);
			State = 243;
			Match(ParenClosed);
			State = 244;
			block();
			State = 248;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 245;
					ifElseStatement();
					}
					} 
				}
				State = 250;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			}
			State = 252;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 251;
				elseStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ElseIf() { return GetToken(BilingualParser.ElseIf, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public IfElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifElseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfElseStatementContext ifElseStatement() {
		IfElseStatementContext _localctx = new IfElseStatementContext(Context, State);
		EnterRule(_localctx, 24, RULE_ifElseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 254;
			Match(ElseIf);
			State = 255;
			Match(ParenOpen);
			State = 256;
			expression(0);
			State = 257;
			Match(ParenClosed);
			State = 258;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(BilingualParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseStatementContext elseStatement() {
		ElseStatementContext _localctx = new ElseStatementContext(Context, State);
		EnterRule(_localctx, 26, RULE_elseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 260;
			Match(Else);
			State = 261;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(BilingualParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(Context, State);
		EnterRule(_localctx, 28, RULE_whileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263;
			Match(While);
			State = 264;
			Match(ParenOpen);
			State = 265;
			expression(0);
			State = 266;
			Match(ParenClosed);
			State = 267;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DoWhileStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(BilingualParser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(BilingualParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		public DoWhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_doWhileStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DoWhileStatementContext doWhileStatement() {
		DoWhileStatementContext _localctx = new DoWhileStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_doWhileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 269;
			Match(Do);
			State = 270;
			block();
			State = 271;
			Match(While);
			State = 272;
			Match(ParenOpen);
			State = 273;
			expression(0);
			State = 274;
			Match(ParenClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementContext : ParserRuleContext {
		public ExpressionContext loopCondition;
		public ExpressionContext alterIndex;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(BilingualParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(BilingualParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ForStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementContext forStatement() {
		ForStatementContext _localctx = new ForStatementContext(Context, State);
		EnterRule(_localctx, 32, RULE_forStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 276;
			Match(For);
			State = 277;
			Match(ParenOpen);
			State = 278;
			variableDeclaration();
			State = 279;
			_localctx.loopCondition = expression(0);
			State = 280;
			Match(Semicolon);
			State = 281;
			_localctx.alterIndex = expression(0);
			State = 282;
			Match(ParenClosed);
			State = 283;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForEachStatementContext : ParserRuleContext {
		public IToken item;
		public ExpressionContext collection;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Foreach() { return GetToken(BilingualParser.Foreach, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode In() { return GetToken(BilingualParser.In, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName() { return GetToken(BilingualParser.MemberName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ForEachStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forEachStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForEachStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForEachStatementContext forEachStatement() {
		ForEachStatementContext _localctx = new ForEachStatementContext(Context, State);
		EnterRule(_localctx, 34, RULE_forEachStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 285;
			Match(Foreach);
			State = 286;
			Match(ParenOpen);
			State = 287;
			_localctx.item = Match(MemberName);
			State = 288;
			Match(In);
			State = 289;
			_localctx.collection = expression(0);
			State = 290;
			Match(ParenClosed);
			State = 291;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DialogueStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName() { return GetToken(BilingualParser.MemberName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(BilingualParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(BilingualParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InterpolationStringContext interpolationString() {
			return GetRuleContext<InterpolationStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DialogueEmotionContext dialogueEmotion() {
			return GetRuleContext<DialogueEmotionContext>(0);
		}
		public DialogueStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dialogueStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDialogueStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DialogueStatementContext dialogueStatement() {
		DialogueStatementContext _localctx = new DialogueStatementContext(Context, State);
		EnterRule(_localctx, 36, RULE_dialogueStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 293;
			Match(MemberName);
			State = 295;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ParenOpen) {
				{
				State = 294;
				dialogueEmotion();
				}
			}

			State = 297;
			Match(Colon);
			State = 300;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case String:
				{
				State = 298;
				Match(String);
				}
				break;
			case DollarDouble:
				{
				State = 299;
				interpolationString();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DialogueEmotionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MemberName() { return GetToken(BilingualParser.MemberName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		public DialogueEmotionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dialogueEmotion; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDialogueEmotion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DialogueEmotionContext dialogueEmotion() {
		DialogueEmotionContext _localctx = new DialogueEmotionContext(Context, State);
		EnterRule(_localctx, 38, RULE_dialogueEmotion);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 302;
			Match(ParenOpen);
			State = 303;
			Match(MemberName);
			State = 304;
			Match(ParenClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChooseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ChooseBlockContext[] chooseBlock() {
			return GetRuleContexts<ChooseBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ChooseBlockContext chooseBlock(int i) {
			return GetRuleContext<ChooseBlockContext>(i);
		}
		public ChooseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_chooseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChooseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChooseStatementContext chooseStatement() {
		ChooseStatementContext _localctx = new ChooseStatementContext(Context, State);
		EnterRule(_localctx, 40, RULE_chooseStatement);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 306;
			chooseBlock();
			State = 307;
			chooseBlock();
			State = 311;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 308;
					chooseBlock();
					}
					} 
				}
				State = 313;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChooseBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Choose() { return GetToken(BilingualParser.Choose, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ChooseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_chooseBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChooseBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChooseBlockContext chooseBlock() {
		ChooseBlockContext _localctx = new ChooseBlockContext(Context, State);
		EnterRule(_localctx, 42, RULE_chooseBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 314;
			Match(Choose);
			State = 315;
			expression(0);
			State = 316;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Await() { return GetToken(BilingualParser.Await, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParamContext[] param() {
			return GetRuleContexts<ParamContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParamContext param(int i) {
			return GetRuleContext<ParamContext>(i);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 319;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Await) {
				{
				State = 318;
				Match(Await);
				}
			}

			State = 321;
			member();
			State = 322;
			Match(ParenOpen);
			State = 326;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 3)) & ~0x3f) == 0 && ((1L << (_la - 3)) & 4665729764115087621L) != 0)) {
				{
				{
				State = 323;
				param();
				}
				}
				State = 328;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 329;
			Match(ParenClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(BilingualParser.Comma, 0); }
		public ParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_param; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamContext param() {
		ParamContext _localctx = new ParamContext(Context, State);
		EnterRule(_localctx, 46, RULE_param);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 331;
			expression(0);
			State = 333;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Comma) {
				{
				State = 332;
				Match(Comma);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayIndexerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareOpen() { return GetToken(BilingualParser.SquareOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareClosed() { return GetToken(BilingualParser.SquareClosed, 0); }
		public ArrayIndexerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayIndexer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayIndexer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayIndexerContext arrayIndexer() {
		ArrayIndexerContext _localctx = new ArrayIndexerContext(Context, State);
		EnterRule(_localctx, 48, RULE_arrayIndexer);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 335;
			Match(SquareOpen);
			State = 336;
			expression(0);
			State = 337;
			Match(SquareClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayObjectContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareOpen() { return GetToken(BilingualParser.SquareOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareClosed() { return GetToken(BilingualParser.SquareClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(BilingualParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(BilingualParser.Comma, i);
		}
		public ArrayObjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayObject; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayObject(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayObjectContext arrayObject() {
		ArrayObjectContext _localctx = new ArrayObjectContext(Context, State);
		EnterRule(_localctx, 50, RULE_arrayObject);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 339;
			Match(SquareOpen);
			State = 345;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,22,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 340;
					expression(0);
					State = 341;
					Match(Comma);
					}
					} 
				}
				State = 347;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,22,Context);
			}
			State = 349;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 3)) & ~0x3f) == 0 && ((1L << (_la - 3)) & 4665729764115087621L) != 0)) {
				{
				State = 348;
				expression(0);
				}
			}

			State = 351;
			Match(SquareClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayAccessContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayIndexerContext arrayIndexer() {
			return GetRuleContext<ArrayIndexerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(BilingualParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrayObjectContext arrayObject() {
			return GetRuleContext<ArrayObjectContext>(0);
		}
		public ArrayAccessContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayAccess; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayAccess(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayAccessContext arrayAccess() {
		ArrayAccessContext _localctx = new ArrayAccessContext(Context, State);
		EnterRule(_localctx, 52, RULE_arrayAccess);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 356;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case String:
				{
				State = 353;
				Match(String);
				}
				break;
			case MemberName:
				{
				State = 354;
				member();
				}
				break;
			case SquareOpen:
				{
				State = 355;
				arrayObject();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 358;
			arrayIndexer();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RunStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Run() { return GetToken(BilingualParser.Run, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public RunStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_runStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRunStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RunStatementContext runStatement() {
		RunStatementContext _localctx = new RunStatementContext(Context, State);
		EnterRule(_localctx, 54, RULE_runStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 360;
			Match(Run);
			State = 361;
			member();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InjectStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Inject() { return GetToken(BilingualParser.Inject, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public InjectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_injectStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInjectStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InjectStatementContext injectStatement() {
		InjectStatementContext _localctx = new InjectStatementContext(Context, State);
		EnterRule(_localctx, 56, RULE_injectStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 363;
			Match(Inject);
			State = 364;
			member();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryIncrementLeftContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Add() { return GetTokens(BilingualParser.Add); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Add(int i) {
			return GetToken(BilingualParser.Add, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public UnaryIncrementLeftContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryIncrementLeft; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryIncrementLeft(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryIncrementLeftContext unaryIncrementLeft() {
		UnaryIncrementLeftContext _localctx = new UnaryIncrementLeftContext(Context, State);
		EnterRule(_localctx, 58, RULE_unaryIncrementLeft);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 366;
			Match(Add);
			State = 367;
			Match(Add);
			State = 368;
			member();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryIncrementRightContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Add() { return GetTokens(BilingualParser.Add); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Add(int i) {
			return GetToken(BilingualParser.Add, i);
		}
		public UnaryIncrementRightContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryIncrementRight; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryIncrementRight(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryIncrementRightContext unaryIncrementRight() {
		UnaryIncrementRightContext _localctx = new UnaryIncrementRightContext(Context, State);
		EnterRule(_localctx, 60, RULE_unaryIncrementRight);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 370;
			member();
			State = 371;
			Match(Add);
			State = 372;
			Match(Add);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryDecrementLeftContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Sub() { return GetTokens(BilingualParser.Sub); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sub(int i) {
			return GetToken(BilingualParser.Sub, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public UnaryDecrementLeftContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryDecrementLeft; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryDecrementLeft(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryDecrementLeftContext unaryDecrementLeft() {
		UnaryDecrementLeftContext _localctx = new UnaryDecrementLeftContext(Context, State);
		EnterRule(_localctx, 62, RULE_unaryDecrementLeft);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 374;
			Match(Sub);
			State = 375;
			Match(Sub);
			State = 376;
			member();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryDecrementRightContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Sub() { return GetTokens(BilingualParser.Sub); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sub(int i) {
			return GetToken(BilingualParser.Sub, i);
		}
		public UnaryDecrementRightContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryDecrementRight; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryDecrementRight(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryDecrementRightContext unaryDecrementRight() {
		UnaryDecrementRightContext _localctx = new UnaryDecrementRightContext(Context, State);
		EnterRule(_localctx, 64, RULE_unaryDecrementRight);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 378;
			member();
			State = 379;
			Match(Sub);
			State = 380;
			Match(Sub);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlusMinusMulDivEqualContext : ParserRuleContext {
		public PlusMinusMulDivEqualContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plusMinusMulDivEqual; } }
	 
		public PlusMinusMulDivEqualContext() { }
		public virtual void CopyFrom(PlusMinusMulDivEqualContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MulDivEqualToContext : PlusMinusMulDivEqualContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MulEqual() { return GetToken(BilingualParser.MulEqual, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DivEqual() { return GetToken(BilingualParser.DivEqual, 0); }
		public MulDivEqualToContext(PlusMinusMulDivEqualContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulDivEqualTo(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PlusMinusEqualToContext : PlusMinusMulDivEqualContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PlusEqual() { return GetToken(BilingualParser.PlusEqual, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MinusEqual() { return GetToken(BilingualParser.MinusEqual, 0); }
		public PlusMinusEqualToContext(PlusMinusMulDivEqualContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlusMinusEqualTo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PlusMinusMulDivEqualContext plusMinusMulDivEqual() {
		PlusMinusMulDivEqualContext _localctx = new PlusMinusMulDivEqualContext(Context, State);
		EnterRule(_localctx, 66, RULE_plusMinusMulDivEqual);
		int _la;
		try {
			State = 390;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				_localctx = new MulDivEqualToContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 382;
				member();
				State = 383;
				_la = TokenStream.LA(1);
				if ( !(_la==MulEqual || _la==DivEqual) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 384;
				expression(0);
				}
				break;
			case 2:
				_localctx = new PlusMinusEqualToContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 386;
				member();
				State = 387;
				_la = TokenStream.LA(1);
				if ( !(_la==PlusEqual || _la==MinusEqual) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 388;
				expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncrementsAndDecrementsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnaryIncrementLeftContext unaryIncrementLeft() {
			return GetRuleContext<UnaryIncrementLeftContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryIncrementRightContext unaryIncrementRight() {
			return GetRuleContext<UnaryIncrementRightContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryDecrementLeftContext unaryDecrementLeft() {
			return GetRuleContext<UnaryDecrementLeftContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryDecrementRightContext unaryDecrementRight() {
			return GetRuleContext<UnaryDecrementRightContext>(0);
		}
		public IncrementsAndDecrementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_incrementsAndDecrements; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncrementsAndDecrements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IncrementsAndDecrementsContext incrementsAndDecrements() {
		IncrementsAndDecrementsContext _localctx = new IncrementsAndDecrementsContext(Context, State);
		EnterRule(_localctx, 68, RULE_incrementsAndDecrements);
		try {
			State = 396;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 392;
				unaryIncrementLeft();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 393;
				unaryIncrementRight();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 394;
				unaryDecrementLeft();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 395;
				unaryDecrementRight();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringContentsContext : ParserRuleContext {
		public StringContentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringContents; } }
	 
		public StringContentsContext() { }
		public virtual void CopyFrom(StringContentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StringContentGraphemesContext : StringContentsContext {
		[System.Diagnostics.DebuggerNonUserCode] public LotsOfGraphemesContext lotsOfGraphemes() {
			return GetRuleContext<LotsOfGraphemesContext>(0);
		}
		public StringContentGraphemesContext(StringContentsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringContentGraphemes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringContentExprContext : StringContentsContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyOpen() { return GetToken(BilingualParser.CurlyOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyClosed() { return GetToken(BilingualParser.CurlyClosed, 0); }
		public StringContentExprContext(StringContentsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringContentExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringContentPluralizedContext : StringContentsContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyOpen() { return GetToken(BilingualParser.CurlyOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PluralizedQuantityContext pluralizedQuantity() {
			return GetRuleContext<PluralizedQuantityContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyClosed() { return GetToken(BilingualParser.CurlyClosed, 0); }
		public StringContentPluralizedContext(StringContentsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringContentPluralized(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringContentsContext stringContents() {
		StringContentsContext _localctx = new StringContentsContext(Context, State);
		EnterRule(_localctx, 70, RULE_stringContents);
		try {
			State = 407;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
			case 1:
				_localctx = new StringContentGraphemesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 398;
				lotsOfGraphemes();
				}
				break;
			case 2:
				_localctx = new StringContentExprContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 399;
				Match(CurlyOpen);
				State = 400;
				expression(0);
				State = 401;
				Match(CurlyClosed);
				}
				break;
			case 3:
				_localctx = new StringContentPluralizedContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 403;
				Match(CurlyOpen);
				State = 404;
				pluralizedQuantity();
				State = 405;
				Match(CurlyClosed);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LotsOfGraphemesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Grapheme() { return GetTokens(BilingualParser.Grapheme); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Grapheme(int i) {
			return GetToken(BilingualParser.Grapheme, i);
		}
		public LotsOfGraphemesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lotsOfGraphemes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLotsOfGraphemes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LotsOfGraphemesContext lotsOfGraphemes() {
		LotsOfGraphemesContext _localctx = new LotsOfGraphemesContext(Context, State);
		EnterRule(_localctx, 72, RULE_lotsOfGraphemes);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 410;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 409;
					Match(Grapheme);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 412;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InterpolationStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DollarDouble() { return GetToken(BilingualParser.DollarDouble, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleQuote() { return GetToken(BilingualParser.DoubleQuote, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringContentsContext[] stringContents() {
			return GetRuleContexts<StringContentsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringContentsContext stringContents(int i) {
			return GetRuleContext<StringContentsContext>(i);
		}
		public InterpolationStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interpolationString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterpolationString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InterpolationStringContext interpolationString() {
		InterpolationStringContext _localctx = new InterpolationStringContext(Context, State);
		EnterRule(_localctx, 74, RULE_interpolationString);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 414;
			Match(DollarDouble);
			State = 418;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1+1 ) {
					{
					{
					State = 415;
					stringContents();
					}
					} 
				}
				State = 420;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			}
			State = 421;
			Match(DoubleQuote);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PluralizedQuantityContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenOpen() { return GetToken(BilingualParser.ParenOpen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(BilingualParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(BilingualParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PluralCountParamContext[] pluralCountParam() {
			return GetRuleContexts<PluralCountParamContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PluralCountParamContext pluralCountParam(int i) {
			return GetRuleContext<PluralCountParamContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ParenClosed() { return GetToken(BilingualParser.ParenClosed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plural() { return GetToken(BilingualParser.Plural, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ordinal() { return GetToken(BilingualParser.Ordinal, 0); }
		public PluralizedQuantityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pluralizedQuantity; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPluralizedQuantity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PluralizedQuantityContext pluralizedQuantity() {
		PluralizedQuantityContext _localctx = new PluralizedQuantityContext(Context, State);
		EnterRule(_localctx, 76, RULE_pluralizedQuantity);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 423;
			_la = TokenStream.LA(1);
			if ( !(_la==Plural || _la==Ordinal) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 424;
			Match(ParenOpen);
			State = 425;
			expression(0);
			State = 426;
			Match(Comma);
			State = 427;
			pluralCountParam();
			State = 432;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1+1 ) {
					{
					{
					State = 428;
					Match(Comma);
					State = 429;
					pluralCountParam();
					}
					} 
				}
				State = 434;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
			}
			State = 435;
			Match(ParenClosed);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PluralCountParamContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(BilingualParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(BilingualParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Zero() { return GetToken(BilingualParser.Zero, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode One() { return GetToken(BilingualParser.One, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Two() { return GetToken(BilingualParser.Two, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Other() { return GetToken(BilingualParser.Other, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Few() { return GetToken(BilingualParser.Few, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Many() { return GetToken(BilingualParser.Many, 0); }
		public PluralCountParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pluralCountParam; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBilingualParserVisitor<TResult> typedVisitor = visitor as IBilingualParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPluralCountParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PluralCountParamContext pluralCountParam() {
		PluralCountParamContext _localctx = new PluralCountParamContext(Context, State);
		EnterRule(_localctx, 78, RULE_pluralCountParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 437;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 35465847065542656L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 438;
			Match(Equal);
			State = 439;
			Match(String);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 4: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 16);
		case 1: return Precpred(Context, 15);
		case 2: return Precpred(Context, 14);
		case 3: return Precpred(Context, 13);
		case 4: return Precpred(Context, 12);
		case 5: return Precpred(Context, 7);
		case 6: return Precpred(Context, 6);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,69,442,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,1,0,4,0,82,8,0,11,0,12,0,83,1,
		0,3,0,87,8,0,1,1,1,1,1,1,5,1,92,8,1,10,1,12,1,95,9,1,1,1,1,1,1,2,5,2,100,
		8,2,10,2,12,2,103,9,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
		1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,3,
		4,134,8,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,4,1,4,1,4,5,4,157,8,4,10,4,12,4,160,9,4,1,5,1,5,1,5,1,5,
		3,5,166,8,5,1,6,1,6,1,6,5,6,171,8,6,10,6,12,6,174,9,6,1,6,3,6,177,8,6,
		1,7,1,7,1,7,1,7,1,7,1,7,3,7,185,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
		1,7,1,7,1,7,1,7,3,7,217,8,7,1,8,3,8,220,8,8,1,8,1,8,1,8,1,8,1,8,1,8,1,
		9,1,9,1,9,1,9,1,10,1,10,5,10,234,8,10,10,10,12,10,237,9,10,1,10,1,10,1,
		11,1,11,1,11,1,11,1,11,1,11,5,11,247,8,11,10,11,12,11,250,9,11,1,11,3,
		11,253,8,11,1,12,1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,
		1,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,
		1,16,1,16,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,
		1,18,3,18,296,8,18,1,18,1,18,1,18,3,18,301,8,18,1,19,1,19,1,19,1,19,1,
		20,1,20,1,20,5,20,310,8,20,10,20,12,20,313,9,20,1,21,1,21,1,21,1,21,1,
		22,3,22,320,8,22,1,22,1,22,1,22,5,22,325,8,22,10,22,12,22,328,9,22,1,22,
		1,22,1,23,1,23,3,23,334,8,23,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,5,
		25,344,8,25,10,25,12,25,347,9,25,1,25,3,25,350,8,25,1,25,1,25,1,26,1,26,
		1,26,3,26,357,8,26,1,26,1,26,1,27,1,27,1,27,1,28,1,28,1,28,1,29,1,29,1,
		29,1,29,1,30,1,30,1,30,1,30,1,31,1,31,1,31,1,31,1,32,1,32,1,32,1,32,1,
		33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,391,8,33,1,34,1,34,1,34,1,34,
		3,34,397,8,34,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,408,8,
		35,1,36,4,36,411,8,36,11,36,12,36,412,1,37,1,37,5,37,417,8,37,10,37,12,
		37,420,9,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,5,38,431,8,38,
		10,38,12,38,434,9,38,1,38,1,38,1,39,1,39,1,39,1,39,1,39,2,418,432,1,8,
		40,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,
		48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,0,9,2,0,17,17,19,20,1,
		0,21,22,1,0,23,24,1,0,25,26,1,0,30,31,1,0,15,16,1,0,13,14,1,0,55,56,1,
		0,49,54,466,0,81,1,0,0,0,2,88,1,0,0,0,4,101,1,0,0,0,6,109,1,0,0,0,8,133,
		1,0,0,0,10,165,1,0,0,0,12,176,1,0,0,0,14,216,1,0,0,0,16,219,1,0,0,0,18,
		227,1,0,0,0,20,235,1,0,0,0,22,240,1,0,0,0,24,254,1,0,0,0,26,260,1,0,0,
		0,28,263,1,0,0,0,30,269,1,0,0,0,32,276,1,0,0,0,34,285,1,0,0,0,36,293,1,
		0,0,0,38,302,1,0,0,0,40,306,1,0,0,0,42,314,1,0,0,0,44,319,1,0,0,0,46,331,
		1,0,0,0,48,335,1,0,0,0,50,339,1,0,0,0,52,356,1,0,0,0,54,360,1,0,0,0,56,
		363,1,0,0,0,58,366,1,0,0,0,60,370,1,0,0,0,62,374,1,0,0,0,64,378,1,0,0,
		0,66,390,1,0,0,0,68,396,1,0,0,0,70,407,1,0,0,0,72,410,1,0,0,0,74,414,1,
		0,0,0,76,423,1,0,0,0,78,437,1,0,0,0,80,82,3,2,1,0,81,80,1,0,0,0,82,83,
		1,0,0,0,83,81,1,0,0,0,83,84,1,0,0,0,84,86,1,0,0,0,85,87,5,0,0,1,86,85,
		1,0,0,0,86,87,1,0,0,0,87,1,1,0,0,0,88,89,3,20,10,0,89,93,5,1,0,0,90,92,
		3,4,2,0,91,90,1,0,0,0,92,95,1,0,0,0,93,91,1,0,0,0,93,94,1,0,0,0,94,96,
		1,0,0,0,95,93,1,0,0,0,96,97,5,2,0,0,97,3,1,0,0,0,98,100,3,6,3,0,99,98,
		1,0,0,0,100,103,1,0,0,0,101,99,1,0,0,0,101,102,1,0,0,0,102,104,1,0,0,0,
		103,101,1,0,0,0,104,105,5,57,0,0,105,106,5,5,0,0,106,107,5,6,0,0,107,108,
		3,12,6,0,108,5,1,0,0,0,109,110,5,3,0,0,110,111,5,57,0,0,111,112,5,5,0,
		0,112,113,3,8,4,0,113,114,5,6,0,0,114,115,5,4,0,0,115,7,1,0,0,0,116,117,
		6,4,-1,0,117,118,5,5,0,0,118,119,3,8,4,0,119,120,5,6,0,0,120,134,1,0,0,
		0,121,122,5,11,0,0,122,134,3,8,4,11,123,124,5,22,0,0,124,134,3,8,4,10,
		125,126,5,21,0,0,126,134,3,8,4,9,127,134,3,66,33,0,128,134,3,68,34,0,129,
		134,3,44,22,0,130,134,3,20,10,0,131,134,3,52,26,0,132,134,3,10,5,0,133,
		116,1,0,0,0,133,121,1,0,0,0,133,123,1,0,0,0,133,125,1,0,0,0,133,127,1,
		0,0,0,133,128,1,0,0,0,133,129,1,0,0,0,133,130,1,0,0,0,133,131,1,0,0,0,
		133,132,1,0,0,0,134,158,1,0,0,0,135,136,10,16,0,0,136,137,5,18,0,0,137,
		157,3,8,4,17,138,139,10,15,0,0,139,140,7,0,0,0,140,157,3,8,4,16,141,142,
		10,14,0,0,142,143,7,1,0,0,143,157,3,8,4,15,144,145,10,13,0,0,145,146,5,
		12,0,0,146,157,3,8,4,14,147,148,10,12,0,0,148,149,5,10,0,0,149,157,3,8,
		4,13,150,151,10,7,0,0,151,152,7,2,0,0,152,157,3,8,4,8,153,154,10,6,0,0,
		154,155,7,3,0,0,155,157,3,8,4,7,156,135,1,0,0,0,156,138,1,0,0,0,156,141,
		1,0,0,0,156,144,1,0,0,0,156,147,1,0,0,0,156,150,1,0,0,0,156,153,1,0,0,
		0,157,160,1,0,0,0,158,156,1,0,0,0,158,159,1,0,0,0,159,9,1,0,0,0,160,158,
		1,0,0,0,161,166,3,50,25,0,162,166,7,4,0,0,163,166,5,58,0,0,164,166,5,65,
		0,0,165,161,1,0,0,0,165,162,1,0,0,0,165,163,1,0,0,0,165,164,1,0,0,0,166,
		11,1,0,0,0,167,177,3,14,7,0,168,172,5,1,0,0,169,171,3,14,7,0,170,169,1,
		0,0,0,171,174,1,0,0,0,172,170,1,0,0,0,172,173,1,0,0,0,173,175,1,0,0,0,
		174,172,1,0,0,0,175,177,5,2,0,0,176,167,1,0,0,0,176,168,1,0,0,0,177,13,
		1,0,0,0,178,179,3,30,15,0,179,180,5,7,0,0,180,217,1,0,0,0,181,182,3,36,
		18,0,182,184,5,7,0,0,183,185,5,59,0,0,184,183,1,0,0,0,184,185,1,0,0,0,
		185,217,1,0,0,0,186,187,3,18,9,0,187,188,5,7,0,0,188,217,1,0,0,0,189,190,
		3,44,22,0,190,191,5,7,0,0,191,217,1,0,0,0,192,193,3,68,34,0,193,194,5,
		7,0,0,194,217,1,0,0,0,195,196,3,66,33,0,196,197,5,7,0,0,197,217,1,0,0,
		0,198,199,3,54,27,0,199,200,5,7,0,0,200,217,1,0,0,0,201,202,3,56,28,0,
		202,203,5,7,0,0,203,217,1,0,0,0,204,205,5,39,0,0,205,217,5,7,0,0,206,207,
		5,40,0,0,207,217,5,7,0,0,208,209,5,41,0,0,209,217,5,7,0,0,210,217,3,22,
		11,0,211,217,3,16,8,0,212,217,3,28,14,0,213,217,3,32,16,0,214,217,3,34,
		17,0,215,217,3,40,20,0,216,178,1,0,0,0,216,181,1,0,0,0,216,186,1,0,0,0,
		216,189,1,0,0,0,216,192,1,0,0,0,216,195,1,0,0,0,216,198,1,0,0,0,216,201,
		1,0,0,0,216,204,1,0,0,0,216,206,1,0,0,0,216,208,1,0,0,0,216,210,1,0,0,
		0,216,211,1,0,0,0,216,212,1,0,0,0,216,213,1,0,0,0,216,214,1,0,0,0,216,
		215,1,0,0,0,217,15,1,0,0,0,218,220,5,44,0,0,219,218,1,0,0,0,219,220,1,
		0,0,0,220,221,1,0,0,0,221,222,5,43,0,0,222,223,5,57,0,0,223,224,5,9,0,
		0,224,225,3,8,4,0,225,226,5,7,0,0,226,17,1,0,0,0,227,228,3,20,10,0,228,
		229,5,9,0,0,229,230,3,8,4,0,230,19,1,0,0,0,231,232,5,57,0,0,232,234,5,
		27,0,0,233,231,1,0,0,0,234,237,1,0,0,0,235,233,1,0,0,0,235,236,1,0,0,0,
		236,238,1,0,0,0,237,235,1,0,0,0,238,239,5,57,0,0,239,21,1,0,0,0,240,241,
		5,32,0,0,241,242,5,5,0,0,242,243,3,8,4,0,243,244,5,6,0,0,244,248,3,12,
		6,0,245,247,3,24,12,0,246,245,1,0,0,0,247,250,1,0,0,0,248,246,1,0,0,0,
		248,249,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,0,251,253,3,26,13,0,252,
		251,1,0,0,0,252,253,1,0,0,0,253,23,1,0,0,0,254,255,5,33,0,0,255,256,5,
		5,0,0,256,257,3,8,4,0,257,258,5,6,0,0,258,259,3,12,6,0,259,25,1,0,0,0,
		260,261,5,34,0,0,261,262,3,12,6,0,262,27,1,0,0,0,263,264,5,35,0,0,264,
		265,5,5,0,0,265,266,3,8,4,0,266,267,5,6,0,0,267,268,3,12,6,0,268,29,1,
		0,0,0,269,270,5,36,0,0,270,271,3,12,6,0,271,272,5,35,0,0,272,273,5,5,0,
		0,273,274,3,8,4,0,274,275,5,6,0,0,275,31,1,0,0,0,276,277,5,37,0,0,277,
		278,5,5,0,0,278,279,3,16,8,0,279,280,3,8,4,0,280,281,5,7,0,0,281,282,3,
		8,4,0,282,283,5,6,0,0,283,284,3,12,6,0,284,33,1,0,0,0,285,286,5,38,0,0,
		286,287,5,5,0,0,287,288,5,57,0,0,288,289,5,45,0,0,289,290,3,8,4,0,290,
		291,5,6,0,0,291,292,3,12,6,0,292,35,1,0,0,0,293,295,5,57,0,0,294,296,3,
		38,19,0,295,294,1,0,0,0,295,296,1,0,0,0,296,297,1,0,0,0,297,300,5,8,0,
		0,298,301,5,65,0,0,299,301,3,74,37,0,300,298,1,0,0,0,300,299,1,0,0,0,301,
		37,1,0,0,0,302,303,5,5,0,0,303,304,5,57,0,0,304,305,5,6,0,0,305,39,1,0,
		0,0,306,307,3,42,21,0,307,311,3,42,21,0,308,310,3,42,21,0,309,308,1,0,
		0,0,310,313,1,0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,312,41,1,0,0,0,313,
		311,1,0,0,0,314,315,5,46,0,0,315,316,3,8,4,0,316,317,3,12,6,0,317,43,1,
		0,0,0,318,320,5,42,0,0,319,318,1,0,0,0,319,320,1,0,0,0,320,321,1,0,0,0,
		321,322,3,20,10,0,322,326,5,5,0,0,323,325,3,46,23,0,324,323,1,0,0,0,325,
		328,1,0,0,0,326,324,1,0,0,0,326,327,1,0,0,0,327,329,1,0,0,0,328,326,1,
		0,0,0,329,330,5,6,0,0,330,45,1,0,0,0,331,333,3,8,4,0,332,334,5,28,0,0,
		333,332,1,0,0,0,333,334,1,0,0,0,334,47,1,0,0,0,335,336,5,3,0,0,336,337,
		3,8,4,0,337,338,5,4,0,0,338,49,1,0,0,0,339,345,5,3,0,0,340,341,3,8,4,0,
		341,342,5,28,0,0,342,344,1,0,0,0,343,340,1,0,0,0,344,347,1,0,0,0,345,343,
		1,0,0,0,345,346,1,0,0,0,346,349,1,0,0,0,347,345,1,0,0,0,348,350,3,8,4,
		0,349,348,1,0,0,0,349,350,1,0,0,0,350,351,1,0,0,0,351,352,5,4,0,0,352,
		51,1,0,0,0,353,357,5,65,0,0,354,357,3,20,10,0,355,357,3,50,25,0,356,353,
		1,0,0,0,356,354,1,0,0,0,356,355,1,0,0,0,357,358,1,0,0,0,358,359,3,48,24,
		0,359,53,1,0,0,0,360,361,5,47,0,0,361,362,3,20,10,0,362,55,1,0,0,0,363,
		364,5,48,0,0,364,365,3,20,10,0,365,57,1,0,0,0,366,367,5,21,0,0,367,368,
		5,21,0,0,368,369,3,20,10,0,369,59,1,0,0,0,370,371,3,20,10,0,371,372,5,
		21,0,0,372,373,5,21,0,0,373,61,1,0,0,0,374,375,5,22,0,0,375,376,5,22,0,
		0,376,377,3,20,10,0,377,63,1,0,0,0,378,379,3,20,10,0,379,380,5,22,0,0,
		380,381,5,22,0,0,381,65,1,0,0,0,382,383,3,20,10,0,383,384,7,5,0,0,384,
		385,3,8,4,0,385,391,1,0,0,0,386,387,3,20,10,0,387,388,7,6,0,0,388,389,
		3,8,4,0,389,391,1,0,0,0,390,382,1,0,0,0,390,386,1,0,0,0,391,67,1,0,0,0,
		392,397,3,58,29,0,393,397,3,60,30,0,394,397,3,62,31,0,395,397,3,64,32,
		0,396,392,1,0,0,0,396,393,1,0,0,0,396,394,1,0,0,0,396,395,1,0,0,0,397,
		69,1,0,0,0,398,408,3,72,36,0,399,400,5,1,0,0,400,401,3,8,4,0,401,402,5,
		2,0,0,402,408,1,0,0,0,403,404,5,1,0,0,404,405,3,76,38,0,405,406,5,2,0,
		0,406,408,1,0,0,0,407,398,1,0,0,0,407,399,1,0,0,0,407,403,1,0,0,0,408,
		71,1,0,0,0,409,411,5,66,0,0,410,409,1,0,0,0,411,412,1,0,0,0,412,410,1,
		0,0,0,412,413,1,0,0,0,413,73,1,0,0,0,414,418,5,62,0,0,415,417,3,70,35,
		0,416,415,1,0,0,0,417,420,1,0,0,0,418,419,1,0,0,0,418,416,1,0,0,0,419,
		421,1,0,0,0,420,418,1,0,0,0,421,422,5,61,0,0,422,75,1,0,0,0,423,424,7,
		7,0,0,424,425,5,5,0,0,425,426,3,8,4,0,426,427,5,28,0,0,427,432,3,78,39,
		0,428,429,5,28,0,0,429,431,3,78,39,0,430,428,1,0,0,0,431,434,1,0,0,0,432,
		433,1,0,0,0,432,430,1,0,0,0,433,435,1,0,0,0,434,432,1,0,0,0,435,436,5,
		6,0,0,436,77,1,0,0,0,437,438,7,8,0,0,438,439,5,9,0,0,439,440,5,65,0,0,
		440,79,1,0,0,0,31,83,86,93,101,133,156,158,165,172,176,184,216,219,235,
		248,252,295,300,311,319,326,333,345,349,356,390,396,407,412,418,432
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
